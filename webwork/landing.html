<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lawn Czar - Evolution</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            /* Deep dark background */
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- Image Assets Removed (Procedural Icons Used) -->

    <script>
        /**
         * Lawn Czar Evolution - Landing Page Motion Graphic
         * Sequentially plays through:
         * 1. Lczarui (Orbit)
         * 2. Lcui (Gears)
         * 3. Ang1 (Math/Theory)
         * 4. Ang9 (Final Dial UI)
         */

        window.addEventListener('load', init);
        window.addEventListener('resize', resizeCanvas);

        const CONFIG = {
            colors: {
                bg: '#050505',
                primary: '#00ff9d', // Neon Green
                secondary: '#00d2ff', // Neon Blue
                highlight: '#ffffff',
                text: '#cccccc',
                dim: '#333333'
            },
            timings: {
                intro: 4000,
                gears: 4000,
                math: 4000,
                transition: 1000
            }
        };

        let canvas, ctx;
        let width, height;
        let center = { x: 0, y: 0 };
        let currentSceneIndex = 0;
        let sceneStartTime = 0;
        let isTransitioning = false;
        let globalTime = 0;

        // Mouse/Touch State
        let pointer = { x: 0, y: 0, isDown: false, interact: false };

        function init() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            // Setup Events
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mousedown', onDown);
            canvas.addEventListener('mouseup', onUp);
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd);

            resizeCanvas();
            startLoop();
        }

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            center.x = width / 2;
            center.y = height / 2;
        }

        // --- Input Handling ---
        function onMove(e) { pointer.x = e.clientX; pointer.y = e.clientY; pointer.interact = true; }
        function onDown(e) { pointer.isDown = true; pointer.interact = true; }
        function onUp(e) { pointer.isDown = false; }
        function onTouchStart(e) {
            e.preventDefault();
            pointer.x = e.touches[0].clientX;
            pointer.y = e.touches[0].clientY;
            pointer.isDown = true;
            pointer.interact = true;
        }
        function onTouchMove(e) {
            e.preventDefault();
            pointer.x = e.touches[0].clientX;
            pointer.y = e.touches[0].clientY;
        }
        function onTouchEnd(e) { pointer.isDown = false; }


        // --- Utils ---
        function easeInOutQuad(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
        function lerp(a, b, t) { return a + (b - a) * t; }
        function drawCircle(x, y, r, stroke, fill) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            if (fill) { ctx.fillStyle = fill; ctx.fill(); }
            if (stroke) { ctx.strokeStyle = stroke; ctx.stroke(); }
            ctx.closePath();
        }

        // --- Scenes ---

        const Scene1_Orbit = {
            angle: 0,
            init: () => { },
            update: (dt) => { Scene1_Orbit.angle += 0.05; },
            draw: (ctx, alpha) => {
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = CONFIG.colors.primary;
                ctx.lineWidth = 2;

                let orbitR = 150;

                // Center
                drawCircle(center.x, center.y, 20, CONFIG.colors.secondary, null);

                // Orbit Path
                ctx.setLineDash([5, 15]);
                drawCircle(center.x, center.y, orbitR, CONFIG.colors.dim, null);
                ctx.setLineDash([]);

                // Orbiting Ball
                let bx = center.x + Math.cos(Scene1_Orbit.angle) * orbitR;
                let by = center.y + Math.sin(Scene1_Orbit.angle) * orbitR;

                drawCircle(bx, by, 10, CONFIG.colors.primary, CONFIG.colors.primary);

                // Connecting Line
                ctx.beginPath();
                ctx.moveTo(center.x, center.y);
                ctx.lineTo(bx, by);
                ctx.strokeStyle = `rgba(0, 255, 157, 0.3)`;
                ctx.stroke();

                ctx.fillStyle = CONFIG.colors.text;
                ctx.font = "20px monospace";
                ctx.textAlign = "center";
                ctx.fillText("PHASE 1: ORIGIN", center.x, center.y + 200);
            }
        };

        const Scene2_Gears = {
            gearAngle: 0,
            balls: [],
            init: () => {
                for (let i = 0; i < 5; i++) Scene2_Gears.balls.push({ offset: i * (Math.PI / 4) });
            },
            update: (dt) => { Scene2_Gears.gearAngle += 0.02; },
            draw: (ctx, alpha) => {
                ctx.globalAlpha = alpha;

                // Simulating the "Clutch" mechanism from lcui1
                let r = 120;

                // Main Gear
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(Scene2_Gears.gearAngle);

                ctx.strokeStyle = CONFIG.colors.secondary;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.stroke();

                // Teeth/Balls
                Scene2_Gears.balls.forEach(b => {
                    let bx = Math.cos(b.offset) * r;
                    let by = Math.sin(b.offset) * r;
                    ctx.beginPath();
                    ctx.arc(bx, by, 15, 0, Math.PI * 2);
                    ctx.fillStyle = CONFIG.colors.text;
                    ctx.fill();
                });

                ctx.restore();

                ctx.fillStyle = CONFIG.colors.text;
                ctx.font = "20px monospace";
                ctx.textAlign = "center";
                ctx.fillText("PHASE 2: MECHANICS", center.x, center.y + 200);
            }
        };

        const Scene3_Math = {
            params: { mAngle: 0 },
            init: () => { },
            update: (dt) => {
                // Auto move the "mouse" angle if user isn't interacting
                if (!pointer.interact) {
                    Scene3_Math.params.mAngle = Math.sin(globalTime * 0.002) * Math.PI;
                } else {
                    Scene3_Math.params.mAngle = Math.atan2(pointer.y - center.y, pointer.x - center.x);
                }
            },
            draw: (ctx, alpha) => {
                ctx.globalAlpha = alpha;

                // Replicating ang1.html geometry visualization
                let angle = Scene3_Math.params.mAngle;
                let r = 180;

                // Arc
                ctx.strokeStyle = CONFIG.colors.dim;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(center.x, center.y, r, Math.PI, 0); // Top half arc
                ctx.stroke();

                // Center
                drawCircle(center.x, center.y, 5, CONFIG.colors.highlight, CONFIG.colors.highlight);

                // Dynamic Line
                let px = center.x + Math.cos(angle) * r;
                let py = center.y + Math.sin(angle) * r;

                // Clamp to top half for visual consistency with ang1 style if desired, or full circle
                // ang1 was an arc path. Let's keep full circle freedom for "Jazz".

                ctx.strokeStyle = CONFIG.colors.primary;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(center.x, center.y);
                ctx.lineTo(px, py);
                ctx.stroke();

                // Tangent/Sine/Cosine visuals
                ctx.strokeStyle = 'rgba(255,0,0,0.5)';
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px, center.y); // Vertical Drop (Sine)
                ctx.stroke();

                ctx.strokeStyle = 'rgba(0,100,255,0.5)';
                ctx.beginPath();
                ctx.moveTo(center.x, center.y);
                ctx.lineTo(px, center.y); // Horizontal (Cosine)
                ctx.stroke();

                ctx.fillStyle = CONFIG.colors.text;
                ctx.font = "20px monospace";
                ctx.textAlign = "center";
                ctx.fillText("PHASE 3: CALCULATION", center.x, center.y + 250);
                ctx.font = "12px monospace";
                ctx.fillText(`A: ${(angle * 180 / Math.PI).toFixed(1)}Â°`, center.x, center.y + 270);
            }
        };

        const Scene4_Dial = {
            // The Final Product (ang9 adapted)
            rotation: 0,
            targetRotation: 0,
            icons: [
                { id: 'help', angle: -90, label: "Help" },
                { id: 'find', angle: -45, label: "Find Route" },
                { id: 'signin', angle: 0, label: "Sign In" },
                { id: 'sale', angle: 45, label: "Sales" },
                { id: 'sync', angle: 90, label: "Sync" }
            ],
            arcRadius: 250,
            activeIcon: null,

            init: () => {
                Scene4_Dial.rotation = 0;
            },
            update: (dt) => {
                // Dial Logic
                // If mouse is near the arc, rotate dial based on mouse position relative to center
                if (pointer.interact) {
                    let dx = pointer.x - center.x;
                    let dy = pointer.y - center.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 100 && dist < 400) {
                        // Calculate desired rotation to bring the closest icon to the mouse?
                        // Or just rotate the whole assembly. 
                        // ang9 logic: clicking left/right increments/decrements angle.
                        // Let's make it direct manipulation:
                        // The dial follows the mouse angle, but dampened.
                        let mAngle = Math.atan2(dy, dx);
                        // We want to rotate the icons such that they follow the mouse?
                        // Let's effectively add an offset to base angles.

                        // Simplified: Interactive "Wheel"
                        Scene4_Dial.targetRotation = mAngle + Math.PI / 2; // Offset so top is 0 roughly
                    }
                }

                // Smooth rotation
                Scene4_Dial.rotation += (Scene4_Dial.targetRotation - Scene4_Dial.rotation) * 0.1;

                // Hittest icons
                Scene4_Dial.activeIcon = null;
                // Check which icon is closest to "Action Line" (e.g. 3 o'clock or mouse?)
                // Let's say mouse hover highlights icons.
            },
            draw: (ctx, alpha) => {
                ctx.globalAlpha = alpha;

                let r = Scene4_Dial.arcRadius;

                // Main Arc
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.translate(0, 200);

                // Draw decorative ring
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, r + 50, Math.PI, 0);
                ctx.stroke();

                // Draw Icons
                Scene4_Dial.icons.forEach(icon => {
                    let rad = (icon.angle) * Math.PI / 180 + Scene4_Dial.rotation;

                    let ix = Math.cos(rad - Math.PI / 2) * r;
                    let iy = Math.sin(rad - Math.PI / 2) * r;

                    // Interaction Check
                    let dmx = pointer.x - (center.x + ix);
                    let dmy = pointer.y - (center.y + 200 + iy);
                    let dist = Math.sqrt(dmx * dmx + dmy * dmy);
                    let hit = dist < 40;

                    if (hit) Scene4_Dial.activeIcon = icon;

                    let size = hit ? 40 : 30; // Radius

                    // Icon Background Bubble
                    ctx.shadowBlur = hit ? 20 : 0;
                    ctx.shadowColor = CONFIG.colors.primary;
                    ctx.fillStyle = hit ? CONFIG.colors.primary : 'rgba(255,255,255,0.1)';
                    ctx.beginPath();
                    ctx.arc(ix, iy, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Draw Symbol
                    ctx.strokeStyle = hit ? '#000' : CONFIG.colors.secondary;
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    switch (icon.id) {
                        case 'help': // Question Mark
                            ctx.moveTo(ix - 10, iy - 5);
                            ctx.bezierCurveTo(ix - 10, iy - 20, ix + 10, iy - 20, ix + 10, iy - 5);
                            ctx.lineTo(ix, iy + 5);
                            ctx.moveTo(ix, iy + 15);
                            ctx.lineTo(ix, iy + 17);
                            break;
                        case 'find': // Magnifying Glass
                            ctx.arc(ix - 5, iy - 5, 10, 0, Math.PI * 2);
                            ctx.moveTo(ix + 4, iy + 4);
                            ctx.lineTo(ix + 12, iy + 12);
                            break;
                        case 'signin': // User
                            ctx.arc(ix, iy - 8, 8, 0, Math.PI * 2); // Head
                            ctx.moveTo(ix - 10, iy + 15);
                            ctx.bezierCurveTo(ix - 10, iy + 5, ix + 10, iy + 5, ix + 10, iy + 15);
                            break;
                        case 'sale': // Dollar/Tag
                            ctx.moveTo(ix, iy - 10); ctx.lineTo(ix, iy + 10);
                            ctx.moveTo(ix - 5, iy - 8);
                            ctx.bezierCurveTo(ix + 15, iy - 8, ix - 15, iy + 8, ix + 5, iy + 8);
                            break;
                        case 'sync': // Refresh Arrows
                            ctx.arc(ix, iy, 12, 0, Math.PI * 1.5);
                            ctx.moveTo(ix, iy - 12); ctx.lineTo(ix + 5, iy - 12); ctx.lineTo(ix, iy - 17);
                            break;
                    }
                    ctx.stroke();

                });

                ctx.restore();

                // Text & UI Lines
                if (Scene4_Dial.activeIcon) {
                    ctx.fillStyle = CONFIG.colors.primary;
                    ctx.font = "bold 60px sans-serif";
                    ctx.textAlign = "right";
                    ctx.fillText(Scene4_Dial.activeIcon.label, width - 50, center.y);

                    // Connect line
                    ctx.strokeStyle = CONFIG.colors.primary;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(width - 50, center.y + 10);
                    ctx.lineTo(width, center.y + 10);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = CONFIG.colors.highlight;
                    ctx.font = "40px sans-serif";
                    ctx.textAlign = "center";
                    ctx.fillText("LAWN CZAR", center.x, center.y - 100);
                    ctx.font = "16px sans-serif";
                    ctx.fillStyle = CONFIG.colors.text;
                    ctx.fillText("Interactive System", center.x, center.y - 70);
                }
            }
        };

        // --- Main Loop ---

        let scenes = [Scene1_Orbit, Scene2_Gears, Scene3_Math, Scene4_Dial];
        Scene2_Gears.init();

        function startLoop() {
            sceneStartTime = Date.now();
            requestAnimationFrame(loop);
        }

        function loop() {
            requestAnimationFrame(loop);

            // Clear
            ctx.fillStyle = CONFIG.colors.bg;
            ctx.fillRect(0, 0, width, height);

            // Time management
            let now = Date.now();
            let elapsed = now - sceneStartTime;
            globalTime += 16;

            let activeScene = scenes[currentSceneIndex];
            let nextScene = scenes[currentSceneIndex + 1];

            // Update
            if (activeScene) activeScene.update(16);

            // Draw Active
            if (activeScene) activeScene.draw(ctx, 1.0);

            // Transition Logic
            // If not the last scene, check timer
            if (currentSceneIndex < scenes.length - 1) {
                let duration = CONFIG.timings.intro;
                if (currentSceneIndex === 1) duration = CONFIG.timings.gears;
                if (currentSceneIndex === 2) duration = CONFIG.timings.math;

                if (elapsed > duration) {
                    // Fade out/in
                    let t = (elapsed - duration) / CONFIG.timings.transition;
                    if (t > 1) {
                        currentSceneIndex++;
                        sceneStartTime = now;
                        // Init next
                        if (scenes[currentSceneIndex].init) scenes[currentSceneIndex].init();
                    } else {
                        // Draw next scene underneath/over?
                        // Crossfade:
                        // Actually, let's just draw next scene with opacity t
                        if (nextScene) {
                            nextScene.update(16);
                            nextScene.draw(ctx, t);
                        }
                        // Fade out current?
                        // activeScene.draw(ctx, 1-t) -> but we already drew it 1.0. 
                        // To do a true crossfade we need to handle clearRect or layering.
                        // Simple hack: Draw a black rect with alpha t over screen, then draw next scene with alpha t?
                        // No, additive blend is better for "Jazz".
                    }
                }
            } else {
                // Final scene stays
            }

            // Overlay: Vignette or Scanline
            let grad = ctx.createRadialGradient(center.x, center.y, height / 2, center.x, center.y, height);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.8)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);
        }

    </script>
</body>

</html>